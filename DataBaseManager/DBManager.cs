using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;
using MongoDB.Driver;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using System.Transactions;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace DataBaseManager
{
    /// <summary>
    /// Interface for a document stored in MongoDB.
    /// Ensures that each document has an Id and a creation timestamp.
    /// </summary>
    public interface IDocument
    {
        [BsonId] // Marks this property as the document's primary key.
        [BsonRepresentation(BsonType.ObjectId)] // Specifies how the Id is stored in BSON.
        string Id { get; set; }

        [BsonDateTimeOptions(Kind = DateTimeKind.Utc)] // Ensures DateTime is stored in UTC.
        DateTime CreatedAtUtc { get; set; }
    }

    /// <summary>
    /// Abstract base class for MongoDB documents, implementing IDocument.
    /// It can be used to ensure Id and CreatedAtUtc are handled consistently.
    /// </summary>
    public abstract class BaseDocument : IDocument
    {
        public string Id { get; set; }
        public DateTime CreatedAtUtc { get; set; }

        protected BaseDocument()
        {
            // Id will be generated by MongoDB if null upon insertion.
            // CreatedAtUtc is set here, but the repository can also enforce it on write.
            CreatedAtUtc = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Generic repository class for MongoDB operations.
    /// </summary>
    /// <typeparam name="TDocument">The type of the document, must implement IDocument.</typeparam>
    public class DBManager<TDocument> where TDocument : IDocument
    {
        private readonly IMongoClient _client; // Keep client for session management (transactions)
        private readonly IMongoDatabase _database;

        private IMongoCollection<TDocument> GetCollection(string collectionName)
        {
            if (string.IsNullOrEmpty(collectionName))
                throw new ArgumentNullException(nameof(collectionName));
            return _database.GetCollection<TDocument>(collectionName);
        }

        /// <summary>
        /// Initializes a new instance of the MongoDbRepository class.
        /// It's recommended to register IMongoClient as a singleton in your DI container.
        /// </summary>
        /// <param name="connectionString">The MongoDB connection string.</param>
        /// <param name="databaseName">The name of the database.</param>
        public MongoDbRepository(string connectionString, string databaseName)
        {
            if (string.IsNullOrEmpty(connectionString)) throw new ArgumentNullException(nameof(connectionString));
            if (string.IsNullOrEmpty(databaseName)) throw new ArgumentNullException(nameof(databaseName));

            _client = new MongoClient(connectionString);
            _database = _client.GetDatabase(databaseName);
        }

        /// <summary>
        /// Initializes a new instance of the MongoDbRepository class using an existing IMongoDatabase instance.
        /// This is useful for dependency injection where IMongoDatabase is already configured.
        /// </summary>
        /// <param name="database">The IMongoDatabase instance.</param>
        public MongoDbRepository(IMongoDatabase database)
        {
            if (database == null) throw new ArgumentNullException(nameof(database));

            _database = database;
            _client = _database.Client; // Get client from database
        }


        #region CRUD Operations

        /// <summary>
        /// Inserts a single document into the collection.
        /// Sets CreatedAtUtc if it's default.
        /// </summary>
        /// <param name="document">The document to insert.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        public virtual async Task InsertOneAsync(string collectionName, TDocument document, CancellationToken cancellationToken = default)
        {
            if (document == null) throw new ArgumentNullException(nameof(document));

            if (document.CreatedAtUtc == default)
            {
                document.CreatedAtUtc = DateTime.UtcNow;
            }
            // MongoDB driver automatically generates ObjectId if Id is null or empty for string representation.
            // If Id is already set (e.g. client-generated ObjectId as string), it will be used.
            var collection = GetCollection(collectionName);
            await collection.InsertOneAsync(document, null, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Inserts multiple documents into the collection (Bulk Import).
        /// Sets CreatedAtUtc for documents where it's default.
        /// </summary>
        /// <param name="documents">The collection of documents to insert.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        public virtual async Task InsertManyAsync(string collectionName, IEnumerable<TDocument> documents, CancellationToken cancellationToken = default)
        {
            if (documents == null || !documents.Any()) throw new ArgumentNullException(nameof(documents));

            var now = DateTime.UtcNow;
            foreach (var doc in documents)
            {
                if (doc.CreatedAtUtc == default)
                {
                    doc.CreatedAtUtc = now;
                }
            }
            // For more complex bulk operations (e.g., mixed inserts, updates, deletes with error handling per item),
            // consider using BulkWriteAsync on the collection.
            var collection = GetCollection(collectionName);
            await collection.InsertManyAsync(documents, new InsertManyOptions { IsOrdered = false }, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Retrieves a document by its Id.
        /// </summary>
        /// <param name="id">The Id of the document (ObjectId as string).</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The document if found; otherwise, null.</returns>
        public virtual async Task<TDocument> GetByIdAsync(string collectionName, string id, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(id) || !ObjectId.TryParse(id, out _))
            {
                throw new ArgumentException("Invalid ObjectId string format.", nameof(id));
            }
            var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, id);
            var collection = GetCollection(collectionName);
            return await collection.Find(filter).FirstOrDefaultAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Retrieves all documents in the collection.
        /// Use with caution on large collections; consider pagination or specific filters.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A list of all documents.</returns>
        public virtual async Task<List<TDocument>> GetAllAsync(string collectionName, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            return await collection.Find(Builders<TDocument>.Filter.Empty).ToListAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Finds documents matching a filter expression.
        /// </summary>
        /// <param name="filterExpression">The LINQ expression to filter documents.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A list of matching documents.</returns>
        public virtual async Task<List<TDocument>> FindAsync(string collectionName, Expression<Func<TDocument, bool>> filterExpression, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            return await collection.Find(filterExpression).ToListAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Finds documents matching a MongoDB FilterDefinition.
        /// This allows for more complex queries that might not be easily expressible with LINQ.
        /// </summary>
        /// <param name="filter">The MongoDB FilterDefinition.</param>
        /// <param name="options">Optional find options (e.g., sort, projection, limit, skip).</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A list of matching documents.</returns>
        public virtual async Task<List<TDocument>> FindAsync(string collectionName, FilterDefinition<TDocument> filter, FindOptions<TDocument, TDocument> options = null, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            return await collection.Find(filter, options).ToListAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Replaces an existing document with a new version.
        /// The document Id must match an existing document.
        /// </summary>
        /// <param name="id">The Id of the document to replace.</param>
        /// <param name="document">The new document.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>True if the document was replaced; false otherwise.</returns>
        public virtual async Task<bool> ReplaceOneAsync(string collectionName, string id, TDocument document, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(id) || !ObjectId.TryParse(id, out _))
            {
                throw new ArgumentException("Invalid ObjectId string format.", nameof(id));
            }
            if (document == null) throw new ArgumentNullException(nameof(document));

            // Ensure the ID in the document matches the ID parameter, or set it.
            // This is important as ReplaceOneAsync uses the filter for matching, but the document provided replaces the entire content.
            document.Id = id;

            var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, id);
            var collection = GetCollection(collectionName);
            var result = await collection.ReplaceOneAsync(filter, document, new ReplaceOptions { IsUpsert = false }, cancellationToken).ConfigureAwait(false);
            return result.IsAcknowledged && result.ModifiedCount > 0;
        }

        /// <summary>
        /// Updates one or more fields of a single document matching the filter.
        /// </summary>
        /// <param name="filter">The filter to select the document to update.</param>
        /// <param name="update">The update definition specifying the changes.</param>
        /// <param name="options">Optional update options (e.g., upsert).</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>True if at least one document was modified; false otherwise.</returns>
        public virtual async Task<bool> UpdateOneAsync(string collectionName, FilterDefinition<TDocument> filter, UpdateDefinition<TDocument> update, UpdateOptions options = null, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            var result = await collection.UpdateOneAsync(filter, update, options, cancellationToken).ConfigureAwait(false);
            return result.IsAcknowledged && result.ModifiedCount > 0;
        }

        /// <summary>
        /// Updates a single attribute of a document identified by its Id.
        /// </summary>
        /// <typeparam name="TField">The type of the field to update.</typeparam>
        /// <param name="id">The Id of the document.</param>
        /// <param name="fieldExpression">An expression selecting the field to update.</param>
        /// <param name="value">The new value for the field.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>True if the document was updated; false otherwise.</returns>
        public virtual async Task<bool> UpdateAttributeAsync<TField>(string collectionName, string id, Expression<Func<TDocument, TField>> fieldExpression, TField value, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(id) || !ObjectId.TryParse(id, out _))
            {
                throw new ArgumentException("Invalid ObjectId string format.", nameof(id));
            }
            var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, id);
            var update = Builders<TDocument>.Update.Set(fieldExpression, value);
            var collection = GetCollection(collectionName);
            var result = await collection.UpdateOneAsync(filter, update, null, cancellationToken).ConfigureAwait(false);
            return result.IsAcknowledged && result.ModifiedCount > 0;
        }

        /// <summary>
        /// Updates one or more fields of multiple documents matching the filter.
        /// </summary>
        /// <param name="filter">The filter to select the documents to update.</param>
        /// <param name="update">The update definition specifying the changes.</param>
        /// <param name="options">Optional update options.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The number of documents modified.</returns>
        public virtual async Task<long> UpdateManyAsync(string collectionName, FilterDefinition<TDocument> filter, UpdateDefinition<TDocument> update, UpdateOptions options = null, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            var result = await collection.UpdateManyAsync(filter, update, options, cancellationToken).ConfigureAwait(false);
            return result.IsAcknowledged ? result.ModifiedCount : 0;
        }

        /// <summary>
        /// Deletes a document by its Id.
        /// </summary>
        /// <param name="id">The Id of the document to delete.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>True if the document was deleted; false otherwise.</returns>
        public virtual async Task<bool> DeleteOneAsync(string collectionName, string id, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(id) || !ObjectId.TryParse(id, out _))
            {
                throw new ArgumentException("Invalid ObjectId string format.", nameof(id));
            }
            var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, id);
            var collection = GetCollection(collectionName);
            var result = await collection.DeleteOneAsync(filter, cancellationToken).ConfigureAwait(false);
            return result.IsAcknowledged && result.DeletedCount > 0;
        }

        /// <summary>
        /// Deletes documents matching a filter expression.
        /// </summary>
        /// <param name="filterExpression">The LINQ expression to filter documents for deletion.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The number of documents deleted.</returns>
        public virtual async Task<long> DeleteManyAsync(string collectionName, Expression<Func<TDocument, bool>> filterExpression, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            var result = await collection.DeleteManyAsync(filterExpression, cancellationToken).ConfigureAwait(false);
            return result.IsAcknowledged ? result.DeletedCount : 0;
        }

        /// <summary>
        /// Deletes documents matching a MongoDB FilterDefinition.
        /// </summary>
        /// <param name="filter">The MongoDB FilterDefinition.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The number of documents deleted.</returns>
        public virtual async Task<long> DeleteManyAsync(string collectionName, FilterDefinition<TDocument> filter, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            var result = await collection.DeleteManyAsync(filter, cancellationToken).ConfigureAwait(false);
            return result.IsAcknowledged ? result.DeletedCount : 0;
        }

        #endregion

        #region Advanced Operations & ERP Considerations

        /// <summary>
        /// Counts the number of documents matching a filter.
        /// </summary>
        /// <param name="filterExpression">The LINQ expression to filter documents.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The count of matching documents.</returns>
        public virtual async Task<long> CountAsync(string collectionName, Expression<Func<TDocument, bool>> filterExpression, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            return await collection.CountDocumentsAsync(filterExpression, null, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Counts the number of documents matching a MongoDB FilterDefinition.
        /// </summary>
        /// <param name="filter">The MongoDB FilterDefinition.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The count of matching documents.</returns>
        public virtual async Task<long> CountAsync(string collectionName, FilterDefinition<TDocument> filter, CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            return await collection.CountDocumentsAsync(filter, null, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Retrieves a paged list of documents matching a filter.
        /// Crucial for ERP systems to display large datasets.
        /// </summary>
        /// <param name="filterExpression">The LINQ expression to filter documents.</param>
        /// <param name="pageNumber">The page number (1-based).</param>
        /// <param name="pageSize">The number of documents per page.</param>
        /// <param name="sortDefinition">Optional sort definition.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A list of documents for the specified page.</returns>
        public virtual async Task<List<TDocument>> GetPagedAsync(
            string collectionName,
            Expression<Func<TDocument, bool>> filterExpression,
            int pageNumber,
            int pageSize,
            SortDefinition<TDocument> sortDefinition = null,
            CancellationToken cancellationToken = default)
        {
            if (pageNumber < 1) throw new ArgumentOutOfRangeException(nameof(pageNumber), "Page number must be 1 or greater.");
            if (pageSize < 1) throw new ArgumentOutOfRangeException(nameof(pageSize), "Page size must be 1 or greater.");

            var collection = GetCollection(collectionName);
            var findFluent = collection.Find(filterExpression);
            if (sortDefinition != null)
            {
                findFluent = findFluent.Sort(sortDefinition);
            }

            return await findFluent
                .Skip((pageNumber - 1) * pageSize)
                .Limit(pageSize)
                .ToListAsync(cancellationToken)
                .ConfigureAwait(false);
        }

        /// <summary>
        /// Retrieves a paged list of documents matching a MongoDB FilterDefinition.
        /// </summary>
        public virtual async Task<List<TDocument>> GetPagedAsync(
            string collectionName,
            FilterDefinition<TDocument> filter,
            int pageNumber,
            int pageSize,
            SortDefinition<TDocument> sortDefinition = null,
            FindOptions<TDocument, TDocument> options = null,
            CancellationToken cancellationToken = default)
        {
            if (pageNumber < 1) throw new ArgumentOutOfRangeException(nameof(pageNumber), "Page number must be 1 or greater.");
            if (pageSize < 1) throw new ArgumentOutOfRangeException(nameof(pageSize), "Page size must be 1 or greater.");

            options ??= new FindOptions<TDocument, TDocument>();
            options.Skip = (pageNumber - 1) * pageSize;
            options.Limit = pageSize;
            options.Sort = sortDefinition; // Overwrites if already set in options

            var collection = GetCollection(collectionName);
            return await collection.Find(filter, options).ToListAsync(cancellationToken).ConfigureAwait(false);
        }


        /// <summary>
        /// Executes a series of operations within a MongoDB transaction.
        /// This is vital for maintaining data integrity in ERP systems.
        /// Requires a replica set configuration for MongoDB.
        /// </summary>
        /// <param name="operations">A function that takes a session handle and performs database operations.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        public virtual async Task ExecuteInTransactionAsync(Func<IClientSessionHandle, Task> operations, CancellationToken cancellationToken = default)
        {
            // Transactions require a replica set. Ensure your MongoDB deployment supports them.
            using (var session = await _client.StartSessionAsync(null, cancellationToken).ConfigureAwait(false))
            {
                session.StartTransaction(new TransactionOptions(
                    readConcern: ReadConcern.Snapshot, // Or other levels like Majority
                    writeConcern: WriteConcern.WMajority)); // Ensures durability

                try
                {
                    await operations(session).ConfigureAwait(false);
                    await session.CommitTransactionAsync(cancellationToken).ConfigureAwait(false);
                }
                catch (Exception)
                {
                    // Log the exception
                    await session.AbortTransactionAsync(cancellationToken).ConfigureAwait(false);
                    throw; // Re-throw the exception to be handled by the caller
                }
            }
        }

        /// <summary>
        /// Creates an index on the collection for specified keys.
        /// Proper indexing is paramount for ERP system performance.
        /// </summary>
        /// <param name="keys">The definition of the keys for the index.</param>
        /// <param name="options">Optional index creation options (e.g., unique, sparse).</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The name of the created index.</returns>
        public virtual async Task<string> CreateIndexAsync(string collectionName, IndexKeysDefinition<TDocument> keys, CreateIndexOptions options = null, CancellationToken cancellationToken = default)
        {
            var indexModel = new CreateIndexModel<TDocument>(keys, options);
            var collection = GetCollection(collectionName);
            return await collection.Indexes.CreateOneAsync(indexModel, null, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Performs an aggregation operation on the collection.
        /// Essential for complex reporting and data analysis in ERPs.
        /// </summary>
        /// <typeparam name="TResult">The type of the result documents from the aggregation pipeline.</typeparam>
        /// <param name="pipeline">The aggregation pipeline definition.</param>
        /// <param name="options">Optional aggregation options.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A list of result documents.</returns>
        public virtual async Task<List<TResult>> AggregateAsync<TResult>(
            string collectionName,
            PipelineDefinition<TDocument, TResult> pipeline,
            AggregateOptions options = null,
            CancellationToken cancellationToken = default)
        {
            var collection = GetCollection(collectionName);
            var cursor = await collection.AggregateAsync(pipeline, options, cancellationToken).ConfigureAwait(false);
            return await cursor.ToListAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Provides direct access to the IMongoCollection for operations not covered by this repository.
        /// Use with caution, as it bypasses repository logic (like setting CreatedAtUtc automatically).
        /// </summary>
        public IMongoCollection<TDocument> GetCollectionHandle(string collectionName) => GetCollection(collectionName);

        #endregion

        #region ERP System Specific Considerations (Conceptual)
        // Auditing:
        // - Consider adding CreatedBy/ModifiedBy fields to IDocument or a base class.
        // - Implement hooks or use MongoDB Change Streams to capture changes for an audit log.

        // Soft Deletes:
        // - Instead of hard deleting, add an IsDeleted flag to documents.
        // - Modify repository methods (Get, Find, etc.) to automatically filter out soft-deleted documents
        //   unless explicitly requested. This requires TDocument to implement an ISoftDeletable interface.

        // Concurrency Control:
        // - Optimistic Concurrency: Add a Version property (e.g., int or Guid) to your documents.
        //   Increment it on each update. When updating, check if the Version matches the one in the database.
        //   The MongoDB driver can help manage this.
        //   Example: Builders<TDocument>.Filter.And(
        //                Builders<TDocument>.Filter.Eq(d => d.Id, id),
        //                Builders<TDocument>.Filter.Eq(d => d.Version, currentVersion))

        // Schema Versioning & Migration:
        // - For long-lived ERP systems, document schemas will evolve.
        // - Implement a strategy for migrating data to new schema versions (e.g., on-read migration,
        //   background migration scripts). This is typically handled outside the repository but is a key consideration.

        // Multi-Tenancy:
        // - If your ERP is multi-tenant, you'll need a strategy for data isolation (e.g., tenantId field in
        //   all documents, separate databases per tenant, or separate collections per tenant).
        // - The repository might need to be tenant-aware, automatically applying tenant filters.
        #endregion
    }

    // Example of how you might define a document:
    // public class Product : IDocument // Or inherit from BaseDocument
    // {
    //     public string Id { get; set; }
    //     public DateTime CreatedAtUtc { get; set; }
    //
    //     public string Name { get; set; }
    //     public decimal Price { get; set; }
    //     public int StockQuantity { get; set; }
    //     public string Category { get; set; }
    //     // ... other product properties
    //
    //     public Product()
    //     {
    //         // If not using BaseDocument, ensure CreatedAtUtc is initialized or handled by repository.
    //         // Id can be left null/empty to be generated by MongoDB.
    //     }
    // }
}